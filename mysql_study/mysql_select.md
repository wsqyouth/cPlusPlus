#### mysql架构
MySQL 的架构共分为两层：Server 层和存储引擎层。
* Server 层负责建立连接、分析和执行 SQL。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。
* 存储引擎层负责数据的存储和提取。支持 InnoDB、MyISAM、Memory 等多个存储引擎。从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎，InnoDB 支持索引类型是 B+树。


### 第一步：连接器
连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的。
如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。
```jsx
 show processlist; 查看 MySQL 服务被多少个客户端连接
 show variables like 'wait_timeout'; MySQL 定义了空闲连接的最大空闲时长，由 wait_timeout 参数控制的，默认值是 8 小时（28880秒）.
 show variables like 'max_connections'; 最大连接数由 max_connections 参数
```

长连接与短连接：
使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。
但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。
有两种解决方式。
第一种，定期断开长连接。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。
第二种，客户端主动重置连接。

### 第二步：查询缓存
如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，命中则返回。
挺鸡肋: 对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。
因此MySQL8.0版本直接将查询缓存删掉了。

### 第三步：解析 SQL
第一，词法分析。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。
第二，语法分析。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

### 第四步：执行 SQL
prepare 阶段，也就是预处理阶段； 检查 SQL 查询语句中的表或者字段是否存在； 将 select * 中的 * 符号，扩展为表上的所有列；
optimize 阶段，也就是优化阶段；主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。explain命令
execute 阶段，也就是执行阶段；执行器和存储引擎的交互过程
1. 主键索引查询
查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询
2. 全表扫描
查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询
3. 索引下推
索引下推能够减少二级索引在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。


参考：
[第4部分每个索引的执行流程讲的很好，可以再温故看下]
https://xiaolincoding.com/mysql/base/how_select.html#%E6%89%A7%E8%A1%8C%E5%99%A8
